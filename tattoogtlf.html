<!doctype html>
<html lang="en">
	<head>
		<title>Tattoo Simulation</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			*{ box-sizing: border-box; margin: 0; padding: 0 }
			body {
				color: #888;
				font-family: tahoma;
				font-size:13px;
				background-color: #222;
				margin: 0px;
				overflow: hidden;
				text-shadow: 0 1px 0 rgba( 0,0,0,.5 )
			}
			.intro{ position: absolute; left: 10px; top: 10px; line-height: 1.4em }
			a{ color: inherit }
			#container canvas{ position: absolute; left: 0; top: 0; width: 100%; height: 100%; bottom: 0;}
			b{ color: #aaa;}
#drop-area {position: absolute; left: 10px; top: 20px;
  border: 2px dashed #ccc;
  border-radius: 5px;
  width: 150px;
  font-family: sans-serif;
  margin: 5px auto;
  padding: 5px;
}
#drop-area.highlight {
  border-color: purple;
}
p {
  margin-top: 0;
}
.my-form {
  margin-bottom: 5px;
}
#gallery {
  margin-top: 5px;
}
#gallery img {
  width: 140px;
  margin-bottom: 5px;
  margin-right: 5px;
  vertical-align: left;
}
.button {
  display: inline-block;
  padding: 5px;
  background: #ccc;
  cursor: pointer;
  border-radius: 5px;
  border: 1px solid #ccc;
}
.button:hover {<h1 class="glow">Change Tattoo</h1>
  <img src="assets/rarrow2.png" onclick="prevTattoo()"></img>
		<img src="assets/garrow2.png" onclick="nextTattoo()" ></img><br>
  background: #ddd;
}
#fileElem {
  display: none;
}
.glow {
  font-size: 13px;
  color: #000;
  text-align: left;
  -webkit-animation: glow 1s ease-in-out infinite alternate;
  -moz-animation: glow 1s ease-in-out infinite alternate;
  animation: glow 1s ease-in-out infinite alternate;
}

@-webkit-keyframes glow {
  from {
    text-shadow: 0 0 4px #fda, 0 0 6px #fda, 0 0 8px #fda, 0 0 10px #dfa, 0 0 12px #dfa, 0 0 15px #efb, 0 0 16px #ffc;
  }
  
  to {
    text-shadow: 0 0 5px #ffc, 0 0 7px #ffb, 0 0 9px #ffa, 0 0 11px #efa, 0 0 13px #dfa, 0 0 15px #cfa, 0 0 17px #bfa;
  }
}
		</style>
		
	</head>
	<body>
		<script src="js/Three.js"></script>
		<script src="js/OrbitControls.js"></script>
		<script src="js/OBJLoader.js"></script>
		<script src="js/THREE.DecalGeometry.js"></script>
		<script src="js/dat.gui.min.js"></script>
		<script src="js/KeyboardState.js"></script>
		<script type="text/javascript" src="js/keyboardTattoo.js"></script>
		
		<div id="container"></div>
		<div class="intro" >
			<p><b>Tattoo visualiser</b> | Click or tap and drag to rotate, mouse wheel or pinch to zoom, click or tap to place the Tattoo.</p><br>
		<div id="drop-area">
  <form class="my-form">
   <!-- <p>Upload a new tattoo:</p>
    <input type="file" id="fileElem" onchange="addTattoo(this.files[0])">
    <label class="button" for="fileElem">Select a tattoo</label> -->
    <h1 class="glow">Change Tattoo</h1>
  <img src="assets/rarrow2.png" onclick="prevTattoo()"></img>
		<img src="assets/garrow2.png" onclick="nextTattoo()" ></img><br>
		<h1 class="glow">Change Skin Colour</h1>
  <img src="assets/rarrow2.png" onclick="prevSkin()"></img>
		<img src="assets/garrow2.png" onclick="nextSkin()" ></img><br>
  </form>

</div>
		</div>
		



<script>

var container = document.getElementById( 'container' );

var renderer, scene, helperScene, camera, fov = 45;
var mesh, decal, cube, cubeC;
var projector, raycaster;
var line;
var spotLight, pointLight, ambientLight;
var key;
var intersection = {
	intersects: false,
	point: new THREE.Vector3(),
	normal: new THREE.Vector3()
};
var controls, renderHelpers = false;
var materialC;
var mouseVector = new THREE.Vector3();
var mouse = new THREE.Vector2();
var addFile = 0;
var skinType = 0;
var designs = ['assets/1ss.png','assets/2ss.png','assets/3ss.png','assets/4ss.png','assets/5ss.png','assets/6ss.png','assets/7ss.png','assets/8ss.png','assets/9ss.png','assets/10ss.png',
'assets/11ss.png','assets/12ss.png','assets/13ss.png','assets/14ss.png','assets/15ss.png','assets/16ss.png','assets/17ss.png','assets/18ss.png','assets/19ss.png','assets/20ss.png',
'assets/21ss.png','assets/22ss.png','assets/23ss.png','assets/24ss.png','assets/25ss.png','assets/26ss.png','assets/27ss.png','assets/28ss.png','assets/29ss.png','assets/30ss.png',
	      'assets/31ss.png','assets/32ss.png','assets/33ss.png','assets/34ss.png','assets/35ss.png','assets/36ss.png','assets/37ss.png','assets/38ss.png','assets/39ss.png','assets/40ss.png'];
var skins = ['assets/Map-COL.jpg','assets/Map-COL2.jpg', 'assets/Map-COL2.jpg', 'assets/Map-COL3.jpg'];
	      

const boxWidth = 15;
const boxHeight = 15;
const boxDepth = 15;
 



var decalMaterial = new THREE.MeshPhongMaterial( { 
	specular: 0xffffff,
	shininess: 10,
	map: THREE.ImageUtils.loadTexture( designs[addFile] ), 
	normalMap: THREE.ImageUtils.loadTexture( 'assets/wrinkle-normal.jpg' ),
	normalScale: new THREE.Vector2( .15, .15 ),
	transparent: true, 
	depthTest: true, 
	depthWrite: false, 
	polygonOffset: true,
	polygonOffsetFactor: -4, 
	wireframe: false 
});
/*decalMaterial = new THREE.MeshNormalMaterial( { 
	transparent: true, 
	depthTest: true, 
	depthWrite: false, 
	polygonOffset: true,
	polygonOffsetFactor: -4, 
	shading: THREE.SmoothShading
});*/
var decals = [];
var decalHelper, mouseHelper;
var p = new THREE.Vector3( 0, 0, 0 );
var r = new THREE.Vector3( 0, 0, 0 );
var s = new THREE.Vector3( 10, 10, 10 );
var up = new THREE.Vector3( 0, 1, 0 );
var check = new THREE.Vector3( 1, 1, 1 );

var params = {
	projection: 'normal',
	Scale: 10,
	rotate: 0,
	clear: function() {
		removeDecals();
	}
};

window.addEventListener( 'load', init );



function init() {

	renderer = new THREE.WebGLRenderer( { antialias: true });
	renderer.setSize( window.innerWidth, window.innerHeight );	

	container.appendChild( renderer.domElement );
	//holder.appendChild( renderer.domElement );
	scene = new THREE.Scene();
	helperScene = new THREE.Scene();

	camera = new THREE.PerspectiveCamera( fov, window.innerWidth / window.innerHeight, 1, 1000 );
	camera.position.z = 100;
	camera.target = new THREE.Vector3();
	controls = new THREE.OrbitControls( camera, renderer.domElement );
	
	scene.add( camera );

	ambientLight = new THREE.AmbientLight( 0xFFFFFFFFF );
	scene.add( ambientLight );

	pointLight = new THREE.PointLight( 0xffffff );
	pointLight.position.z = 50;
	pointLight.distance = 50;
	scene.add( pointLight );
	pointLight = new THREE.PointLight( 0xffEEEE );
	pointLight.position.z = -50;
	pointLight.distance = 50;
	scene.add( pointLight );

	pointLight2 = new THREE.PointLight( 0xffEEEE );
	pointLight2.position.z = 50;
	pointLight2.distance = 50;
	scene.add( pointLight2 );

	pointLight3 = new THREE.PointLight( 0xddddff );
	pointLight3.position.x = -50;
	pointLight3.position.z = 50;
	pointLight3.distance = 50;
	scene.add( pointLight3 );
	pointLight3 = new THREE.PointLight( 0xddddff );
	pointLight3.position.x = 10;
	pointLight3.position.z = 10;
	pointLight3.distance = 20;
	scene.add( pointLight3 );
	pointLight3 = new THREE.PointLight( 0xddddff );
	pointLight3.position.y = 50;
	pointLight3.position.z = -50;
	pointLight3.distance = 50;
	scene.add( pointLight3 );

	spotLight = new THREE.SpotLight( 0xaaaaaa );
	spotLight.position.set( 10, 50, 10 );
	scene.add( spotLight );

	line = new THREE.Line( new THREE.Geometry( ), new THREE.LineBasicMaterial( { linewidth: 4 }) );
	line.geometry.vertices.push( new THREE.Vector3( 0, 0, 0 ) );
	line.geometry.vertices.push( new THREE.Vector3( 0, 0, 0 ) );
	scene.add( line );
	
	
	document.addEventListener('DOMContentLoaded', () => {
    'use strict';
	document.addEventListener('keydown', event => {
		const charList = 'bn';
        key = event.key.toLowerCase();

        // we are only interested in alphanumeric keys
        if (charList.indexOf(key) === -1) return;

        console.log(key);

    });
    
    console.log('content loaded');
});
 


	newCube();
	loadLeePerrySmith();

	projector = new THREE.Projector();
	raycaster = new THREE.Raycaster();

	mouseHelper = new THREE.Mesh( new THREE.BoxGeometry( 1, 1, 10 ), new THREE.MeshNormalMaterial() );
	scene.add( mouseHelper );
	mouseHelper.visible = false;

	window.addEventListener( 'resize', onWindowResize, false );

	var moved = false;

	controls.addEventListener( 'change', function() {
		moved = true;
	} );

	controls.addEventListener( 'start', function() {
		moved = false;
	} );

	controls.addEventListener( 'end', function() {
		checkIntersection();
		if( !moved ) shoot();
	} );

    window.addEventListener( 'mousemove', onTouchMove );
    window.addEventListener( 'touchmove', onTouchMove );

    function onTouchMove( event ) {

        if( event.changedTouches ) {
            x = event.changedTouches[ 0 ].pageX;
            y = event.changedTouches[ 0 ].pageY;
        } else {
            x = event.clientX;
            y = event.clientY;
        }
		
		mouse.x = ( x / window.innerWidth ) * 2 - 1;
		mouse.y = - ( y / window.innerHeight ) * 2 + 1;

		checkIntersection();

    }
    
    /*function loadTattoo() {
		this.className = '';
      e.preventDefault();

      var file = e.dataTransfer.files[0];
      var reader = new FileReader();
      reader.onload = function(event) {
        holder.style.background = 
        'url(' + event.target.result + ') no-repeat center';

        var image = document.createElement('img');
        image.src = event.target.result;
        var texture = new THREE.Texture(image);
        texture.needsUpdate = true;

        scene.getObjectByName('cube').material.map = texture;
      };
      reader.readAsDataURL(file);
      return false;
	}*/

    function checkIntersection() {

    	mouseVector.set( mouse.x, mouse.y, 1 );
		projector.unprojectVector( mouseVector, camera );

		raycaster.set( camera.position, mouseVector.sub( camera.position ).normalize() );

		var intersects = raycaster.intersectObjects( [ mesh ] );

		if ( intersects.length > 0 ) {

			var p = intersects[ 0 ].point;
			mouseHelper.position.copy( p );
			intersection.point.copy( p );
			var n = intersects[ 0 ].face.normal.clone();
			n.multiplyScalar( 10 );
			n.add( intersects[ 0 ].point );
			intersection.normal.copy( intersects[ 0 ].face.normal );
			mouseHelper.lookAt( n );

			line.geometry.vertices[ 0 ].copy( intersection.point );
			line.geometry.vertices[ 1 ].copy( n );
			line.geometry.verticesNeedUpdate = true;

			intersection.intersects = true;

		} else {

			intersection.intersects = false;

		}

    }
	
	var gui = new dat.GUI();

	gui.add( params, 'projection', { 'From cam to mesh': 'camera', 'Normal to mesh': 'normal' } );
	gui.add( params, 'Scale', 1, 30 );
	gui.add( params, 'rotate', 0,360 );
	gui.add( params, 'clear' );
	gui.open();

	onWindowResize();
	render();
	
}

function loadLeePerrySmith( callback ) {
	
	var whichOne = 0;
	
	if(whichOne == 0) {

	var loader = new THREE.JSONLoader();
	

    loader.load( 'assets/LeePerrySmith.js', function( geometry ) {
		//loader.load( 'assets/standard-male-figure.json', function( geometry ) {
			

    	geometry.verticesNeedUpdate = true;
		geometry.elementsNeedUpdate = true;
		geometry.morphTargetsNeedUpdate = true;
		geometry.uvsNeedUpdate = true;
		geometry.normalsNeedUpdate = true;
		geometry.colorsNeedUpdate = true;
		geometry.tangentsNeedUpdate = true;

		var material = new THREE.MeshPhongMaterial( {
			map: THREE.ImageUtils.loadTexture( skins[0] ),
			specularMap: THREE.ImageUtils.loadTexture( 'assets/Map-SPEC.jpg' ),
			normalMap: THREE.ImageUtils.loadTexture( 'assets/Map-NOR.jpg' ),
			shininess: 10
		} );

		mesh = new THREE.Mesh( geometry, material );
		scene.add( mesh );
		mesh.scale.set( 7, 7, 7 );

		//scene.add( new THREE.FaceNormalsHelper( mesh, 1 ) );
		//scene.add( new THREE.VertexNormalsHelper( mesh, 1 ) );

    } );
}
   if(whichOne == 1) {

	var loader = new THREE.JSONLoader();
	

    loader.load( 'assets/model2.glt', function( geometry ) {
		//loader.load( 'assets/standard-male-figure.json', function( geometry ) {
			

    	geometry.verticesNeedUpdate = true;
		geometry.elementsNeedUpdate = true;
		geometry.morphTargetsNeedUpdate = true;
		geometry.uvsNeedUpdate = true;
		geometry.normalsNeedUpdate = true;
		geometry.colorsNeedUpdate = true;
		geometry.tangentsNeedUpdate = true;

		var material = new THREE.MeshPhongMaterial( {
			map: THREE.ImageUtils.loadTexture( 'assets/Map-COL.jpg' ),
			specularMap: THREE.ImageUtils.loadTexture( 'assets/Map-SPEC.jpg' ),
			normalMap: THREE.ImageUtils.loadTexture( 'assets/Map-NOR.jpg' ),
			shininess: 10
		} );

		mesh = new THREE.Mesh( geometry, material );
		scene.add( mesh );
		mesh.scale.set( 7, 7, 7 );

		//scene.add( new THREE.FaceNormalsHelper( mesh, 1 ) );
		//scene.add( new THREE.VertexNormalsHelper( mesh, 1 ) );

    } );
}
    

}

function shoot() {

	if( params.projection == 'camera' ) {

		var dir = camera.target.clone();
		dir.sub( camera.position );

		p = intersection.point;

		var m = new THREE.Matrix4();
		var c = dir.clone();
		c.negate();
		c.multiplyScalar( 10 );
		c.add( p );
		m.lookAt( p, c, up );
		m = m.extractRotation( m );

		dummy = new THREE.Object3D();
		dummy.rotation.setFromRotationMatrix( m );
		r.set( dummy.rotation.x, dummy.rotation.y, dummy.rotation.z );

	} else {

		p = intersection.point;
		r.copy( mouseHelper.rotation );

	}

	var scale = params.Scale;
	s.set( scale, scale, scale );

	 r.z = params.rotate/180*Math.PI;

	/*var dResult = createDecal( 
		mesh, 
		p, 
		r, 
		s,
		check
	);
	decal = new THREE.Mesh( dResult.geometry, decalMaterial );
	scene.add( decal );

	helperScene.add( dResult.helper );
	dResult.helper.visible = false;
	var h = new THREE.BoxHelper( dResult.helper, 0xffffff );
	h.material.linewidth = 2;
	helperScene.add( h );*/

	var m = new THREE.Mesh( new THREE.DecalGeometry( mesh, p, r, s, check ), decalMaterial );
	decals.push( m );
	scene.add( m );

	//renderHelpers = true;

	/*line.geometry.vertices[ 0 ].set( p.x, p.y, p.z );
	line.geometry.vertices[ 1 ].set( c.x, c.y, c.z );
	line.geometry.verticesNeedUpdate = true;*/

}

function removeDecals() {

	decals.forEach( function( d ) {
		scene.remove( d );
		d = null;
	} );
	decals = [];

}

/*function addTattoo(file) {
	
	var materialB = new THREE.MeshPhongMaterial( { 
	specular: 0xffffff,
	shininess: 10,
	map: THREE.ImageUtils.loadTexture( designs[addFile] ), 
	normalMap: THREE.ImageUtils.loadTexture( 'assets/wrinkle-normal.jpg' ),
	normalScale: new THREE.Vector2( .01, .01 ),
	transparent: false, 
	depthTest: true, 
	depthWrite: false, 
	polygonOffset: true,
	polygonOffsetFactor: -4, 
	wireframe: false 
});
	cube.material = materialB;
	//cube.position.set(-35,0,10);
	//scene.add(cube);



  decalMaterial = new THREE.MeshPhongMaterial( { 
	specular: 0xffffff,
	shininess: 10,
	map: THREE.ImageUtils.loadTexture( designs[addFile] ), 
	normalMap: THREE.ImageUtils.loadTexture( 'assets/wrinkle-normal.jpg' ),
	normalScale: new THREE.Vector2( .15, .15 ),
	transparent: true, 
	depthTest: true, 
	depthWrite: false, 
	polygonOffset: true,
	polygonOffsetFactor: -4, 
	wireframe: false 
});
}*/





function mergeDecals() {

	var merge = {};
	decals.forEach(function (decal) {
		
		var uuid = decal.material.uuid;
		var d = merge[uuid] = merge[uuid] || {};
		d.material = d.material || decal.material;
		d.geometry = d.geometry || new THREE.Geometry();
		d.geometry.merge(decal.geometry, decal.matrix);
		
	});

	removeDecals();

	for (var key in merge) {
		
		var d = merge[key];
		var mesh = new THREE.Mesh(d.geometry, d.material);
		scene.add(mesh);
		decals.push(mesh);
	
	}

}

function onWindowResize() {

	camera.aspect = window.innerWidth / window.innerHeight;
	camera.updateProjectionMatrix();

	renderer.setSize( window.innerWidth, window.innerHeight );

}

function render() {
	
	requestAnimationFrame( render );
	
	renderer.autoClear = false;
	renderer.render( scene, camera );
	if( renderHelpers ) renderer.render( helperScene, camera );

}

</script>

	</body>
</html>
